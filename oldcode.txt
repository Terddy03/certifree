// --- src/lib/supabase.ts ---
// ... content of supabase.ts ...
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
 
export const supabase = createClient(supabaseUrl, supabaseAnonKey); 

// --- src/hooks/useAuth.ts ---
// ... content of useAuth.ts ...
import { useState, useEffect, useRef } from 'react';
import { supabase } from '@/lib/supabase';
import { User } from '@supabase/supabase-js';
import { UserProgress, UserAchievement } from '@/lib/mock-data/users';
import { componentDebug, startTimer, endTimer } from '@/lib/debugger';

export interface UserProfile {
  id: string;
  email: string;
  fullName: string;
  avatarUrl: string;
  bio?: string;
  subscriptionTier: "free" | "premium";
  learningStreak: number;
  totalCertificationsCompleted: number;
  joinedAt: string;
  isAdmin?: boolean;
  isSuperAdmin?: boolean;
  preferences: {
    emailNotifications: boolean;
    pushNotifications: boolean;
    newsletter: boolean;
    learningReminders: boolean;
  };
  stats: {
    hoursLearned: number;
    averageScore: number;
    skillsLearned: string[];
    currentGoal: string;
  };
  userProgress: UserProgress[];
  userAchievements: UserAchievement[];
}

interface AuthState {
  user: User | null;
  profile: UserProfile | null;
  loading: boolean;
  error: string | null;
}

export const useAuth = () => {
  const debug = componentDebug('useAuth');
  
  const [authState, setAuthState] = useState<AuthState>({
    user: null,
    profile: null,
    loading: true,
    error: null,
  });

  const profileChannelRef = useRef<any | null>(null);

  const subscribeToProfileUpdates = (userId: string) => {
    try {
      if (profileChannelRef.current) {
        supabase.removeChannel(profileChannelRef.current);
        profileChannelRef.current = null;
      }
      const channel = supabase
        .channel(`profiles-changes-${userId}`)
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'profiles', filter: `id=eq.${userId}` }, (payload) => {
          const updated: any = payload.new;
          setAuthState((prev) => {
            if (!prev.user) return prev;
            const mergedProfile: UserProfile = {
              id: updated?.id || prev.profile?.id || userId,
              email: updated?.email || prev.profile?.email || '',
              fullName: updated?.full_name || updated?.fullName || prev.profile?.fullName || 'User',
              avatarUrl: updated?.avatar_url || updated?.avatarUrl || prev.profile?.avatarUrl || '',
              bio: updated?.bio ?? prev.profile?.bio ?? '',
              subscriptionTier: updated?.subscription_tier || updated?.subscriptionTier || prev.profile?.subscriptionTier || 'free',
              learningStreak: updated?.learning_streak || updated?.learningStreak || prev.profile?.learningStreak || 0,
              totalCertificationsCompleted: updated?.total_certifications_completed || updated?.totalCertificationsCompleted || prev.profile?.totalCertificationsCompleted || 0,
              joinedAt: updated?.joined_at || prev.profile?.joinedAt || new Date().toISOString(),
              isAdmin: (updated?.is_admin ?? prev.profile?.isAdmin ?? false) as boolean,
              isSuperAdmin: (updated?.is_super_admin ?? prev.profile?.isSuperAdmin ?? false) as boolean,
              preferences: {
                emailNotifications: updated?.preferences?.emailNotifications ?? prev.profile?.preferences.emailNotifications ?? true,
                pushNotifications: updated?.preferences?.pushNotifications ?? prev.profile?.preferences.pushNotifications ?? true,
                newsletter: updated?.preferences?.newsletter ?? prev.profile?.preferences.newsletter ?? false,
                learningReminders: updated?.preferences?.learningReminders ?? prev.profile?.preferences.learningReminders ?? true,
              },
              stats: {
                hoursLearned: updated?.stats?.hoursLearned || updated?.stats?.hours_learned || prev.profile?.stats.hoursLearned || 0,
                averageScore: updated?.stats?.averageScore || updated?.stats?.average_score || prev.profile?.stats.averageScore || 0,
                skillsLearned: updated?.stats?.skillsLearned || updated?.stats?.skills_learned || prev.profile?.stats.skillsLearned || [],
                currentGoal: updated?.stats?.currentGoal || updated?.stats?.current_goal || prev.profile?.stats.currentGoal || 'Complete your first certification',
              },
              userProgress: prev.profile?.userProgress || [],
              userAchievements: prev.profile?.userAchievements || [],
            };
            debug.log('Profile updated via realtime', { isAdmin: mergedProfile.isAdmin, isSuperAdmin: mergedProfile.isSuperAdmin });
            return { ...prev, profile: mergedProfile };
          });
        })
        .subscribe();
      profileChannelRef.current = channel;
    } catch (err: any) {
      debug.error('Failed to subscribe to profile updates', { error: err.message });
    }
  };

  useEffect(() => {
    const getActiveSession = async () => {
      startTimer('useAuth:getActiveSession');
      debug.log('Starting session fetch');
      
      try {
        const { data: { session }, error } = await supabase.auth.getSession();

        if (error) throw error;

        if (session) {
          debug.log('Session found', { userId: session.user.id });
          setAuthState(prev => ({ ...prev, user: session.user }));
          const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', session.user.id)
            .single();

          if (profileError) throw profileError;

          debug.log('Profile fetched', { profile });
          
          const { data: userProgress, error: userProgressError } = await supabase
            .from('user_progress')
            .select('*')
            .eq('user_id', session.user.id);
          
          if (userProgressError) throw userProgressError;

          debug.log('User progress fetched', { progressCount: userProgress?.length });
          
          const { data: userAchievements, error: userAchievementsError } = await supabase
            .from('user_achievements')
            .select('*')
            .eq('user_id', session.user.id);

          if (userAchievementsError) throw userAchievementsError;

          debug.log('User achievements fetched', { achievementsCount: userAchievements?.length });

          // Transform and provide defaults for missing fields
          const transformedProfile: UserProfile = {
            id: profile?.id || session.user.id,
            email: profile?.email || session.user.email || '',
            fullName: profile?.full_name || profile?.fullName || 'User',
            avatarUrl: profile?.avatar_url || profile?.avatarUrl || '',
            bio: profile?.bio || '',
            subscriptionTier: profile?.subscription_tier || profile?.subscriptionTier || 'free',
            learningStreak: profile?.learning_streak || profile?.learningStreak || 0,
            totalCertificationsCompleted: profile?.total_certifications_completed || profile?.totalCertificationsCompleted || 0,
            joinedAt: profile?.joined_at || profile?.joinedAt || new Date().toISOString(),
            isAdmin: profile?.is_admin || false,
            isSuperAdmin: profile?.is_super_admin || false,
            preferences: {
              emailNotifications: profile?.preferences?.emailNotifications || true,
              pushNotifications: profile?.preferences?.pushNotifications || true,
              newsletter: profile?.preferences?.newsletter || false,
              learningReminders: profile?.preferences?.learningReminders || true,
            },
            stats: {
              hoursLearned: profile?.stats?.hoursLearned || profile?.stats?.hours_learned || 0,
              averageScore: profile?.stats?.averageScore || profile?.stats?.average_score || 0,
              skillsLearned: profile?.stats?.skillsLearned || profile?.stats?.skills_learned || [],
              currentGoal: profile?.stats?.currentGoal || profile?.stats?.current_goal || 'Complete your first certification',
            },
            userProgress: userProgress as UserProgress[] || [],
            userAchievements: userAchievements as UserAchievement[] || [],
          };

          debug.log('Profile transformation complete', { transformedProfile });
          
          setAuthState(prev => ({
            ...prev,
            profile: transformedProfile,
            loading: false,
          }));

          // Subscribe to realtime profile updates for this user
          subscribeToProfileUpdates(session.user.id);
          
          endTimer('useAuth:getActiveSession');
        } else {
          debug.log('No session found');
          setAuthState(prev => ({ ...prev, user: null, profile: null, loading: false }));
          if (profileChannelRef.current) {
            supabase.removeChannel(profileChannelRef.current);
            profileChannelRef.current = null;
          }
        }
      } catch (error: any) {
        debug.error("Error fetching session or profile", { error: error.message });
        setAuthState(prev => ({ ...prev, error: error.message, loading: false }));
      }
    };

    getActiveSession();

    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setAuthState(prev => ({ ...prev, user: session?.user || null, loading: false }));
      if (session?.user) {
        // Re-fetch profile if auth state changes to logged in
        getActiveSession();
        subscribeToProfileUpdates(session.user.id);
      } else {
        if (profileChannelRef.current) {
          supabase.removeChannel(profileChannelRef.current);
          profileChannelRef.current = null;
        }
      }
    });

    return () => {
      if (authListener && authListener.subscription) {
        authListener.subscription.unsubscribe();
      }
      if (profileChannelRef.current) {
        supabase.removeChannel(profileChannelRef.current);
        profileChannelRef.current = null;
      }
    };
  }, []);

  return authState;
}; 

// --- src/lib/progress.ts ---
// ... content of progress.ts ...
import { supabase } from "@/lib/supabase";

export type UserProgressRow = {
  id: string;
  user_id: string;
  certification_id: string;
  status: string; // planned | in_progress | completed | paused
  started_at: string | null;
  completed_at: string | null;
};

export async function isTaking(userId: string, certificationId: string) {
  const { data, error } = await supabase
    .from<UserProgressRow>("user_progress")
    .select("id, status")
    .eq("user_id", userId)
    .eq("certification_id", certificationId)
    .limit(1);
  if (error) return { data: false, error };
  return { data: (data || []).some((r) => r.status === "in_progress"), error: null };
}

export async function startTaking(userId: string, certificationId: string) {
  // Upsert a row with status in_progress
  const { data, error } = await supabase
    .from("user_progress")
    .upsert(
      { user_id: userId, certification_id: certificationId, status: "in_progress", started_at: new Date().toISOString() },
      { onConflict: "user_id,certification_id" }
    );
  return { data, error };
}

export async function stopTaking(userId: string, certificationId: string) {
  // Either delete row or set status back to planned; choose delete for simplicity
  const { data, error } = await supabase
    .from("user_progress")
    .delete()
    .eq("user_id", userId)
    .eq("certification_id", certificationId);
  return { data, error };
}

export async function countTakersFor(certificationIds: string[]) {
  if (certificationIds.length === 0) return {} as Record<string, number>;
  const { data, error } = await supabase
    .from<UserProgressRow>("user_progress")
    .select("certification_id")
    .eq("status", "in_progress")
    .in("certification_id", certificationIds);
  if (error) return {} as Record<string, number>;
  const counts: Record<string, number> = {};
  (data || []).forEach((row) => {
    counts[row.certification_id] = (counts[row.certification_id] || 0) + 1;
  });
  return counts;
} 

// --- src/pages/Favorites.tsx ---
// ... content of Favorites.tsx ...
import React, { useEffect, useState } from "react";
import { Header } from "@/components/layout/Header";
import { Footer } from "@/components/layout/Footer";
import { useAuth } from "@/hooks/useAuth";
import { supabase } from "@/lib/supabase";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Heart, Users, Clock, ExternalLink } from "lucide-react";
import { useToast } from "@/components/ui/use-toast";
import { isFavorited, removeFavorite } from "@/lib/favorites";
import { isTaking, startTaking, stopTaking } from "@/lib/progress";

export default function Favorites() {
  const { profile } = useAuth();
  const { toast } = useToast();
  const [rows, setRows] = useState<any[]>([]);

  useEffect(() => {
    if (!profile?.id) return;
    (async () => {
      const { data, error } = await supabase
        .from("user_favorites")
        .select("certification_id, certifications:certification_id(id, title, provider, description, duration, external_url)");
      if (error) toast({ title: "Failed to load favorites", description: error.message, variant: "destructive" });
      else setRows(data || []);
    })();
  }, [profile?.id]);

  const toggleFavorite = async (certId: string) => {
    if (!profile?.id) return;
    const { error } = await removeFavorite(profile.id, certId);
    if (error) toast({ title: "Could not remove", description: error.message, variant: "destructive" });
    else setRows(prev => prev.filter(r => r.certification_id !== certId));
  };

  const toggleTaking = async (certId: string) => {
    if (!profile?.id) return;
    const { data } = await isTaking(profile.id, certId);
    const { error } = data ? await stopTaking(profile.id, certId) : await startTaking(profile.id, certId);
    if (error) toast({ title: "Could not update", description: error.message, variant: "destructive" });
    else toast({ title: data ? "Stopped" : "Started", description: data ? "No longer taking" : "Tracking started" });
  };

  return (
    <div className="min-h-screen bg-[#000814] text-gray-100">
      <Header />
      <main className="container mx-auto px-6 py-12 md:py-16">
        <h1 className="text-3xl font-extrabold text-white mb-6">Favorite Certifications</h1>
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {rows.map((r) => (
            <Card key={r.certification_id} className="bg-[#001d3d] border-[#003566]">
              <CardHeader>
                <CardTitle className="text-white text-base">{r.certifications.title}</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="flex items-start gap-3 text-xs text-gray-300">
                  <div className="w-16 h-6 rounded bg-[#003566] flex items-center justify-center text-[10px] text-gray-200 flex-shrink-0">{r.certifications.provider}</div>
                  <p className="text-gray-400 line-clamp-2">{r.certifications.description}</p>
                </div>
                <div className="flex items-center gap-4 text-xs text-gray-400">
                  <Clock className="h-4 w-4 text-gray-500" />
                  <span>{r.certifications.duration}</span>
                </div>
                <div className="flex gap-3">
                  <Button variant="outline" className="border-[#003566] text-gray-300" onClick={() => toggleTaking(r.certification_id)}>I am taking this cert</Button>
                  <Button variant="ghost" size="icon" className="text-red-500" onClick={() => toggleFavorite(r.certification_id)}><Heart className="h-5 w-5 fill-red-500" /></Button>
                  <Button variant="outline" size="icon" asChild className="bg-[#003566] text-[#ffd60a] border-[#001d3d] hover:bg-[#001d3d]">
                    <a href={r.certifications.external_url} target="_blank" rel="noopener noreferrer"><ExternalLink className="h-5 w-5" /></a>
                  </Button>
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
        {rows.length === 0 && (
          <p className="text-gray-400">No favorites yet.</p>
        )}
      </main>
      <Footer />
    </div>
  );
} 

// --- src/lib/certifree-api.ts ---
// ... content of certifree-api.ts ...
it is a new file

// --- src/lib/types/certifree.ts ---
// ... content of types/certifree.ts ...
it is a new file

// --- src/hooks/useGlobalStats.ts ---
// ... content of useGlobalStats.ts ...
import { useState, useEffect } from 'react';
import { supabase } from '@/lib/supabase';

interface GlobalStats {
  totalUsers: number;
  totalCertifications: number;
  totalCertificationsCompleted: number;
}

export const useGlobalStats = () => {
  const [stats, setStats] = useState<GlobalStats>({
    totalUsers: 0,
    totalCertifications: 0,
    totalCertificationsCompleted: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStats = async () => {
      setLoading(true);
      setError(null);
      try {
        // Fetch total users
        const { count: totalUsers, error: usersError } = await supabase
          .from('profiles')
          .select('id', { count: 'exact' });
        if (usersError) throw usersError;

        // Fetch total certifications available
        const { count: totalCertifications, error: certsError } = await supabase
          .from('certifications')
          .select('id', { count: 'exact' });
        if (certsError) throw certsError;

        // Fetch total certifications completed across all users
        const { count: totalCertificationsCompleted, error: progressError } = await supabase
          .from('user_progress')
          .select('id', { count: 'exact' })
          .eq('status', 'completed');
        if (progressError) throw progressError;

        setStats({
          totalUsers: totalUsers || 0,
          totalCertifications: totalCertifications || 0,
          totalCertificationsCompleted: totalCertificationsCompleted || 0,
        });
      } catch (err: any) {
        console.error("Error fetching global stats:", err.message);
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };
    fetchStats();
  }, []);

  return { stats, loading, error };
}; 


// --- src/pages/Courses.tsx ---
// ... content of Courses.tsx ...
it doesnt have courses.tsx

// --- src/pages/CertificationDetail.tsx ---
// ... content of CertificationDetail.tsx ...
import React, { useEffect, useState } from "react";
import { useParams, Link } from "react-router-dom";
import { Header } from "@/components/layout/Header";
import { Footer } from "@/components/layout/Footer";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Star, Clock, Users, ExternalLink, BookOpen, Check } from "lucide-react";
import { supabase } from "@/lib/supabase";
import { Certification } from "@/lib/mock-data/certifications";
import { componentDebug } from "@/lib/debugger";
import { useAuth } from "@/hooks/useAuth";
import { isTaking, startTaking, stopTaking } from "@/lib/progress";
import { useToast } from "@/components/ui/use-toast";

const CertificationDetail = () => {
  const { id } = useParams<{ id: string }>();
  const [certification, setCertification] = useState<Certification | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const debug = componentDebug('CertificationDetail');
  const { profile } = useAuth();
  const { toast } = useToast();
  const [taking, setTaking] = useState(false);
  const [takersCount, setTakersCount] = useState(0);

  useEffect(() => {
    const fetchCertification = async () => {
      if (!id) {
        setError("Certification ID is missing.");
        setLoading(false);
        return;
      }
      debug.log(`Fetching certification with ID: ${id}`);
      setLoading(true);
      setError(null);
      try {
        const { data, error } = await supabase
          .from('certifications')
          .select('*')
          .eq('id', id)
          .single();

        if (error) {
          debug.error("Error fetching certification details", { error: error.message });
          setError(error.message);
        } else if (data) {
          // Transform data from snake_case to camelCase (similar to useCertifications)
          const transformedData: Certification = {
            id: data.id,
            title: data.title,
            provider: data.provider,
            category: data.category,
            difficulty: data.difficulty,
            duration: data.duration,
            rating: data.rating || 0,
            totalReviews: data.total_reviews || 0,
            description: data.description,
            skills: data.skills || [],
            prerequisites: data.prerequisites || [],
            imageUrl: data.image_url || '/api/placeholder/400/240',
            externalUrl: data.external_url || '#',
            isFree: data.is_free || true,
            certificationType: data.certification_type || 'Course',
            careerImpact: data.career_impact || 5,
            completionCount: data.completion_count || 0,
            tags: data.tags || [],
            lastUpdated: data.last_updated || new Date().toISOString().split('T')[0]
          };
          debug.log("Certification fetched successfully", { id, data: transformedData });
          setCertification(transformedData);
        } else {
          setError("Certification not found.");
        }
      } catch (err: any) {
        debug.error("Unhandled error fetching certification", { error: err.message, stack: err.stack });
        setError(err.message);
      } finally {
        setLoading(false);
      }
    };

    fetchCertification();
  }, [id]);

  // Load taking state and count
  useEffect(() => {
    (async () => {
      if (!id) return;
      const { count } = await supabase
        .from('user_progress')
        .select('id', { count: 'exact', head: true })
        .eq('certification_id', id)
        .eq('status', 'in_progress');
      setTakersCount(count || 0);
      if (profile?.id) {
        const { data } = await isTaking(profile.id, id);
        setTaking(!!data);
      }
    })();
  }, [id, profile?.id]);

  const onToggleTaking = async () => {
    if (!profile?.id) return toast({ title: 'Please sign in to track progress.' });
    const next = !taking;
    setTaking(next);
    setTakersCount((c) => Math.max(0, c + (next ? 1 : -1)));
    const { error } = next ? await startTaking(profile.id, id!) : await stopTaking(profile.id, id!);
    if (error) {
      setTaking(!next);
      setTakersCount((c) => Math.max(0, c + (next ? -1 : 1)));
      toast({ title: 'Could not update', description: error.message, variant: 'destructive' });
    }
  };

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-[#000814] text-gray-300">
        <p>Loading certification details...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-[#000814] text-red-500">
        <p>Error: {error}</p>
      </div>
    );
  }

  if (!certification) {
    return (
      <div className="min-h-screen flex flex-col items-center justify-center bg-[#000814] text-gray-300 p-4">
        <BookOpen className="h-16 w-16 text-[#003566] mx-auto mb-4" />
        <h2 className="text-2xl font-bold text-white mb-2">Certification Not Found</h2>
        <p className="text-center text-gray-400 mb-4">The certification you are looking for does not exist or may have been removed.</p>
        <Button asChild className="bg-[#ffc300] text-[#001d3d] font-bold px-6 py-2 rounded-full shadow-md hover:bg-[#ffd60a] transition-colors duration-200">
          <Link to="/certifications">Browse All Certifications</Link>
        </Button>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-[#000814] text-gray-100">
      <Header />
      <main className="container mx-auto px-6 py-12 md:py-16">
        <div className="mb-8">
          <Button variant="link" className="pl-0 text-gray-300 hover:text[#ffd60a] transition-colors duration-200" asChild>
            <Link to="/certifications">&larr; Back to Certifications</Link>
          </Button>
        </div>
        
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          {/* Main Content Area */}
          <div className="lg:col-span-2 space-y-8">
            <Card className="bg-[#001d3d] text-white rounded-xl shadow-xl border border-[#003566]">
              <CardContent className="p-8">
                <div className="flex flex-col sm:flex-row items-center sm:items-start space-y-6 sm:space-y-0 sm:space-x-6 mb-8">
                  {certification.imageUrl?.toLowerCase().endsWith('.pdf') ? (
                    <a href={certification.imageUrl} target="_blank" rel="noopener noreferrer" className="w-32 h-20 flex items-center justify-center rounded-lg flex-shrink-0 shadow-md bg-[#003566] text-xs text-gray-200">View PDF</a>
                  ) : (
                    <img 
                      src={certification.imageUrl} 
                      alt={certification.title}
                      className="w-32 h-20 object-cover rounded-lg flex-shrink-0 shadow-md"
                    />
                  )}
                  <div className="text-center sm:text-left">
                    <h1 className="text-3xl md:text-4xl font-extrabold text-white mb-2 leading-tight">{certification.title}</h1>
                    <div className="flex flex-wrap items-center justify-center sm:justify-start gap-x-4 gap-y-2 text-sm text-gray-400">
                      <Badge className="bg[#003566] text-gray-200 text-xs font-semibold px-3 py-1 rounded-full">
                        {certification.provider}
                      </Badge>
                    </div>
                  </div>
                </div>
                
                <p className="text-base text-gray-300 mb-4 leading-relaxed">{certification.description}</p>
                <div className="flex items-center gap-3 mb-6">
                  <Button variant="outline" onClick={onToggleTaking} className={`${taking ? 'border-green-600 text-green-400' : 'border-[#003566] text-gray-300'} bg-[#001d3d] hover:bg-[#003566]`}>
                    {taking ? "I'm taking this" : "I am taking this cert"}
                  </Button>
                  <div className="flex items-center gap-2 text-sm text-gray-400">
                    <Users className="h-5 w-5 text-gray-500" />
                    <span>{takersCount.toLocaleString()}</span>
                  </div>
                </div>
                
                <Separator className="my-8 bg-[#003566]" />

                <div className="grid grid-cols-1 sm:grid-cols-2 gap-6 text-base text-gray-300">
                  <div className="flex items-center gap-3">
                    <Clock className="h-5 w-5 text-gray-500" />
                    <span>Estimated Time: <span className="font-semibold">{certification.duration}</span></span>
                  </div>
                  <div className="flex items-center gap-3">
                    <Badge variant="outline" className="text-sm bg-[#003566] text-gray-200 border-[#001d3d] font-medium">
                      Type: {certification.certificationType}
                    </Badge>
                  </div>
                </div>

                <Separator className="my-8 bg-[#003566]" />

                <h2 className="text-2xl font-bold text-white mb-5">Skills You'll Gain</h2>
                <div className="flex flex-wrap gap-3 mb-6">
                  {(certification.skills || []).map((skill) => (
                    <Badge key={skill} className="bg-[#003566] text-gray-200 text-sm font-medium px-4 py-1.5 rounded-full">
                      {skill}
                    </Badge>
                  ))}
                </div>

                {certification.prerequisites && certification.prerequisites.length > 0 && (
                  <>
                    <h2 className="text-2xl font-bold text-white mb-5">Prerequisites</h2>
                    <ul className="list-disc list-inside text-gray-400 space-y-2 mb-6 pl-5">
                      {(certification.prerequisites || []).map((prereq, index) => (
                        <li key={index}>{prereq}</li>
                      ))}
                    </ul>
                  </>
                )}
                <div className="flex flex-col sm:flex-row gap-3 mt-6">
                  <Button asChild className="flex-1 bg-[#ffc300] text-[#001d3d] font-bold py-3 px-6 rounded-full shadow-md hover:bg-[#ffd60a] transition-colors duration-200 text-lg">
                    <a href={certification.externalUrl} target="_blank" rel="noopener noreferrer" className="flex items-center justify-center">
                      Start Certification on {certification.provider}
                      <ExternalLink className="ml-3 h-5 w-5" />
                    </a>
                  </Button>
                  <Button variant="outline" onClick={onToggleTaking} className={`${taking ? 'border-green-600 text-green-400' : 'border-[#003566] text-gray-300'} bg-[#001d3d] hover:bg-[#003566]`}> 
                    {taking ? "I'm taking this" : "I am taking this cert"}
                  </Button>
                  <Button variant="outline" className="border-[#003566] text-gray-300 bg-[#001d3d] hover:bg-[#003566]" onClick={async () => {
                    if (!profile?.id) return toast({ title: 'Please sign in to mark completed.' });
                    // Mark as completed by upserting a completed row
                    const { error } = await supabase.from('user_progress').upsert({ user_id: profile.id, certification_id: certification.id, status: 'completed', completed_at: new Date().toISOString() }, { onConflict: 'user_id,certification_id' });
                    if (error) toast({ title: 'Could not mark completed', description: error.message, variant: 'destructive' });
                    else toast({ title: 'Marked as completed' });
                  }}>Mark Completed</Button>
                </div>
              </CardContent>
            </Card>

            {/* Reviews removed by request */}
          </div>

          {/* Sidebar / Related Info (placeholder for now) */}
          <div className="lg:col-span-1 space-y-8">
            <Card className="bg-[#001d3d] text-white rounded-xl shadow-xl border border-[#003566]">
              <CardHeader className="p-8 pb-4">
                <CardTitle className="text-2xl font-bold text-white">Related Certifications</CardTitle>
              </CardHeader>
              <CardContent className="p-8 pt-0">
                <p className="text-gray-400">Coming soon: Dynamically suggested related certifications.</p>
              </CardContent>
            </Card>
          </div>
        </div>
      </main>
      <Footer />
    </div>
  );
};

export default CertificationDetail; 

// Add any other files that interact with Supabase or define relevant types/interfaces




